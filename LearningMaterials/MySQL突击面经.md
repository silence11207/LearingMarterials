# MySQL数据库篇



### 一、MySQL有哪几种数据存储引擎？有什么区别？

> MySQL中通过show ENGINES指令可以看到所有支持的数据库存储引擎，最为常用的MyISAM和InnoDB两种。
>
> MyISAM和InnoDB的区别：

1.  存储文件：MyISAM每个表有两个文件，MYD和MYISAM文件。MYD是数据文件，MYI是索引文件。而InnoDB每个表只有一个文件，ibd。

2.  InnoDB支持事务，支持行级锁，支持外键。

### 二、MySQL的锁有哪些？什么是间隙锁？

> 从锁的粒度来区分

1.  **行锁**：加锁粒度小，但是加锁资源开销比较大。InnoDB支持。

> **共享锁**：读锁。多个事务可以对同一个数据共享同一把锁。持有锁的事务都可以访问数据，但是只能读不能修改。Select xxx LOCK IN SHARE MODE
>
> **排他锁**：写锁。只有一个事务能够获得排它锁。其他事务都不能获取该行的锁。InnoDB会对update\\delete\\insert语句自动添加排他锁。Select xxx FOR UPDATE。
>
> **自增锁**：通常是针对MySQL当中的自增字段。如果有事务回滚这种情况，数据会回滚，但是自增序列不会回滚。

2.  **表锁**：加锁粒度大，加锁资源开销比较小。MyISAM和InnoDB都支持。

> **表共享锁**：
>
> **表排他锁**：
>
> **意向锁**：是InnoDB自动添加的一种锁，不需要用户干预。

3.  **全局锁**： Flush table with read lock, 加锁之后整个数据库实例都处于只读状态。所有的数据变更操作都会被挂起。一般用于全库备份的时候。

> 常见的锁算法：user: userid(1,4,9) update user set xxx where userid=5; REPEATABLE READ 间隙锁锁住（5,9）

1.  记录锁：锁一条具体的数据。
2.  间隙锁：RR隔离级别下，会加间隙锁。锁一定的范围，而不锁具体的记录。是为了防止产生幻读。（-xx,1）(1,4) (4,9) (9,xx)
3.  Next-key:间隙锁+右记录锁。（-xx,1\](1,4\] (4,9\] (9,xx)

### 三、MySQL的索引结构是什么样的？聚簇索引和非聚簇索引又是什么？

> 二叉树--->AVL树红黑树B树-B+树
>
> 二叉树：每个节点最多只有两个节点，左边的子节点都比当前节点小,右边的子节点都比当前节点大。
>
> AVL树：树中任意节点的的两个子树的高度差最大为1
>
> 红黑树：

1.  每个节点都是红色或者黑色

2.  根节点是黑色

3.  每个叶子节点都是黑色的空节点

4.  红色节点的父子节点必须是黑色

5.  从任一节点到其每个叶子节点所有路径都包含相同的黑色节点

> B树：

1.  B树的每个非叶子节点的子节点个数都不会超过D（这个D就是B 树的阶）
2.  所有的叶子节点都在同一层
3.  所有节点关键字都是按照递增顺序排列

![B树](https://upload-images.jianshu.io/upload_images/16722260-767bc294b3220206.png)

> 
>
> B+树

1.  非叶子节点不存储数据，只进行数据索引

2.  所有数据存储在叶子节点当中

3.  每个叶子节点都存有相邻叶子节点的指针

4.  叶子节点按照本身关键字从小到大排序

> ![B+树](https://upload-images.jianshu.io/upload_images/16722260-31aef3dad8651617.png)

> B+树的优点在于：

IO次数更少：由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子节点上关联的数据也具有更好的缓存命中率。

遍历更加方便：B+树的叶子结点都是相链的，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。

> B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。

> ![](https://upload-images.jianshu.io/upload_images/16722260-c46915a0c91a4757.png)

​	B树和B+树的区别图

> 为什么MySQL选择B+树做索引

1. B+树的磁盘读写代价更低

2. B+树的查询效率更加稳定

3. B+树更便于遍历

4. B+树更适合基于范围的查询

   

> 聚簇索引就是数据和索引是在一起的。
>
> MyISAM使用的是非聚簇索引，树的子节点上的data不是数据本身，而是数据存放的地址。
>
> InnoDB采用的是聚簇索引，树的叶子节点上的data就是数据本身。
>
> 聚簇索引的数据物理存放顺序和索引顺序是一致的，所以一个表当中只能有一个聚簇索引，而非聚簇索引可以有多个。
>
> InnoDB中，如果表定义了PK，那PK就是聚簇索引，如果没有PK，就会找第一个非空的unique列作为聚簇索引。否则，InnoDB会创建一个隐藏的ow-id作为聚簇索引。



MySQL的索引覆盖和回表

​	如果只需要在一棵索引树上就可以获取SQL所需要的所有列。就不需要再回表查询。这样查询速度就可以更快。

​	实现索引覆盖最简单的方式就是将要查询的字段，全部建立到联合索引当中。

​	user (PK id, name, sex)

​	select count(name) from user; ->在name字段上建立一个索引。

​	select id, name, sex from user; ->将name上的索引升级成为(name, sex)的联合索引。

### 四、聚簇和非聚簇索引的区别

都是B+树的数据结构

- 聚簇索引：将数据存储与索引放到了一块，并且是按照一定的顺序组织的，找到索引也就找到了数据，数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。

- 非聚簇索引：叶子节点不存储数据，存储的是数据行地址，也就是说根据索引查找到数据行的位置再取磁盘查找数据，这个就有点类似一本书的目录，比如我们要找第三章第一节，那我们先在这个目录里面找，找到对应的页码后再去对应的页码后再去对应的页码看文章。

  ```
  优势：
  1.查询通过聚簇索引可以直接获取数据，相比非聚簇索引需要第二次查询（非覆盖索引的情况下）效率要高
  2.聚簇索引对于范围查询的效率很高，因为其数据是按照大小排列的
  3.聚簇索引适合用在排序的场合，非聚簇索引不适合
  
  劣势：
  1.维护索引很昂贵，特别是插入新行或者主键被更新导致要分页（page split)的时候，建议在大量插入新行后，选在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的行数据可能造成碎片。使用独享表空间可以弱化碎片。
  2.表因为使用UUID(随机ID)作为主键，使数据存储稀疏，这就会出现聚簇索引有可能比全表扫描更慢，所以建议使用int的auto_increment作为主键。
  3.如果主键比较大的话，那辅助索引将会变得更大，因为辅助索引的叶子存储的是主键值：过长的主键值会导致非叶子节点占用更多的物理空间。
  ```

  InnoDB中一定有主键，主键一定是聚簇索引，不手动设置，则会使用unique索引，没有unique索引，则会使用数据库内部的一个行的隐藏id来当作主键索引。在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。

  MyISAM使用的是非聚簇索引，没有聚簇索引，非聚簇索引的两棵B+树开上去没有什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两棵B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引是独立的，通过辅助键索引无需访问主键的索引树。

  如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占空间小，这些操作是需要在内存中完成的。

### 五、MySQL的集群是如何搭建的？读写分离是怎么做的？

MySQL主从集群的搭建原理：

![主从复制原理](https://pic2.zhimg.com/80/v2-3d2ad55d66800f5a8bd3214f29765bad_720w.jpg)

MySQL通过将主节点的BinLog同步给从节点完成主从之间的数据同步。

MySQL的主从集群只会将binlog从主节点同步到从节点，而不会反过来同步。由此也就引申出了读写分离的问题。

因为要保证主从之间的数据一致，写数据的操作只能在主节点完成，而读数据的操作可以在主节点或从节点上完成。

### 六、谈谈如何对MySQL进行分库分表？多大数据量需要进行分库分表？分库分表的方式和分片策略？分库分表的方式和分片策略有哪些？分库分表后，SQL语句的执行流程是怎样的？

**什么是分库分表？**就是当表中的数据量过大时，整个查询效率就会降低得非常明显。这时为了提升查询效率，就要将一个表中的数据分散到**多个数据库的多个表**当中。

分库分表最常用的组件：Mycat\ShardingSphere

数据分片的方式有垂直分片和水平分片。垂直分片就是从业务角度将不同的表拆分到不同的库中，能够解决数据库文件过大的问题，但是不能从根本上解决查询问题。**水平分片**就是从数据角度将一个表中的数据拆分到不同的库或表中，这样可以从根本上数据量过大造成的查询效率低的问题。

**常用的分片策略有：**

​	取余\取模：优点 均匀存放数据，缺点 扩容非常麻烦

​	按照范围分片：比较好扩容，数据分布不够均匀

​	按照时间分片：比较容易将热点数据区分出来

​	按照枚举分片：例如按地区分片

​	按照目标字段前缀指定进行分区：自定义业务规则分片

> 水平分片从理论上突破了单机数据量处理的瓶颈，并且扩展相对自由，是分库分表的标准解决方案

**多大数据量需要进行分库分表**

阿里提供的开发手册当中，建议：一个表的数据量超过500W或者数据文件超过2G，就要考虑分库分表了。

**分库分表后的执行流程**

<img src="https://tanhua11207.oss-cn-shanghai.aliyuncs.com/61d1351e1cf171dc9cf47302d192246.png" style="zoom:80%;" />

一个user表，按照userid进行了分片，然后我需要按照sex字段去查，这要怎么查？强制指定之查一个数据库，要怎么做？查询结果按照userid来排序，要怎么排？

分库分表的问题：跨库查询、跨库排序、分布式事务、公共表、主键重复。



# 搜索引擎篇

### 一、什么是倒排索引？有什么好处？

索引：从ID到内容。

倒排索引：从内容到ID。好处：比较适合做关键字检索。可以控制数据的总量。提高查询效率。

搜索引擎为什么比MySQL查询快？lucence(底层框架)

文章->term->排序 **term dictionary -> term index** -> Posting List->文章ID，[在文章中出现的偏移量]，权重 TFIDF

​		java    1,5,10

